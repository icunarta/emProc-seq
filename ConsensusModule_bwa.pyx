#def Consensus(infile, outfile, RepeatCutoff, ReadLength, totalseq):
def Consensus(infile, outfile, RepeatCutoff, ReadLength):

	import sys	#JHL, 20160303
	import re	#JHL, 20160303
	import math
	from scipy.stats import mode
	from itertools import izip
	
	cdef int i
	cdef int counter_PoorQuality
	cdef int counter_NoRepeats
	cdef int counter_AbnormalRepeatLength
	cdef int counter_LowIdentity
	cdef int counter_TotalReads
	cdef int counter_ConsensusSequences
	
	cdef int StartPosition
	cdef int Identity

	cdef int Seq_Length	#Sam, 20170517: Used filling overhang generated by the trimming during idenity calculation
	cdef int Loop_end	#Sam, 20170517: Used filling overhang generated by the trimming during idenity calculation

	
	counter_PoorQuality = 0
	counter_NoRepeats = 0
	counter_AbnormalRepeatLength = 0
	counter_LowIdentity = 0
	counter_TotalReads = 0
	counter_ConsensusSequences = 0

	#RepeatLengths = [0]*100
	RepeatLengths = [0]*(ReadLength/RepeatCutoff) #JHL, 20160303	


	#seqcount = 0 #JHL, 20160303, progress monitoring
	while True:
	
		#print seqcount, '/', totalseq #JHL, 20160303, progress monitoring
		#print seqcount #JHL, 20160304, progress monitoring
		#seqcount += 1 #JHL, 20160303, progress monitoring
	
		SequenceID = infile.readline()		
		counter_TotalReads += 1
		
		if not SequenceID:					
			break						
		
		Sequence = infile.readline()
		Sequence = Sequence.rstrip("\n")
		EmptyLine = infile.readline()
		QualityScores = infile.readline()
		QualityScores = QualityScores.rstrip("\n")
	
		#Remove the first base which can be error prone
		Sequence = Sequence[1:]
		Seq_Length = len(Sequence)		#Sam, 20170517: Use sequence with first based chopped to define Seq_Length
		QualityScores = QualityScores[1:]
	
		#Remove/count reads with more than 30% Ns
		#if Sequence.count("N") > 90:
		if Sequence.count("N") > 0.3 * Seq_Length: #JHL, 20160303: "90" -> "0.3 * ReadLength"	#Sam, 20170517: Change to Seq_Length to prevent over or undercount.
			counter_PoorQuality += 1
			
		else:
		
			#Identify all possible sets of repeats and save their lengths
			SubstringLengths = []
			i = 1
			#while i <= 291: 
			while i <= Seq_Length - 9: #JHL, 20160303: "291" -> "ReadLength - 9"		#Sam, 20170517: Change to Seq_Length to prevent overloop.
				Substrings = Sequence.split(Sequence[i:i+8]) #JHL, 20160303, 8 as the window size, may be changed in future
				for String in Substrings[1:-1]: #[1:-1] avoids ends which will likely not be the exact repeat length
					SubstringLengths.append(len(String))
				i += 1
			
			#Remove/count reads with no detectable repeats
			if len(SubstringLengths) == 0:
				counter_NoRepeats += 1
				
			else:
				SubstringLengthsMode = mode(SubstringLengths) #mode is an array [0][0] = mode, [1][0] = counts of mode in list
				
				#Remove/count reads with abnormal/non-ideal repeat length
				#if SubstringLengthsMode[0][0] < 17 or SubstringLengthsMode[0][0] > 91: 
				if SubstringLengthsMode[0][0] < 17 or SubstringLengthsMode[0][0] > ReadLength/RepeatCutoff - 9: #JHL, 20160303, "91" -> "ReadLength/RepeatCutoff - 9".
					counter_AbnormalRepeatLength += 1
					#print "Abnormal length: ", SubstringLengthsMode[0][0] #JHL, 20160303, progress monitoring
				
				else:
					#Optimize sequence identity, all possible sets of repeats are considered

					RepeatLength = int(SubstringLengthsMode[0][0]) + 8
					RepeatLengths[RepeatLength] += 1
					RepeatSetIdentities = []
					i = 0

					#JHL, 20160303, rewrite the hardcoded 3 repeats into flexible number
					if RepeatCutoff == 1: #RepeatCutoff=1, all is considered identical (to itself)
						while i < ReadLength - 1 - (RepeatLength*RepeatCutoff): #JHL, 20160303, "299 - (RepeatLength*3)" -> "ReadLength - 1 - (RepeatLength*RepeatCutoff)"
							Identity = RepeatLength
							RepeatSetIdentities.append(Identity)
							i += 1

					elif RepeatCutoff == 2: #fast but stupid hardcode for RepeatCutoff = 2
						while i < ReadLength - 1 - (RepeatLength*RepeatCutoff): #JHL, 20160303, "299 - (RepeatLength*3)" -> "ReadLength - 1 - (RepeatLength*RepeatCutoff)"
							Identity = 0
							for RepeatBase1, RepeatBase2 in zip(Sequence[i:i+RepeatLength], Sequence[i+RepeatLength:i+RepeatLength*2]):
								if RepeatBase1 == RepeatBase2 and RepeatBase1 != "N":
									Identity += 1
							RepeatSetIdentities.append(Identity)
							i += 1

					elif RepeatCutoff == 3: #fast but stupid hardcode for RepeatCutoff = 3
						while i < ReadLength - 1 - (RepeatLength*RepeatCutoff): #JHL, 20160303, "299 - (RepeatLength*3)" -> "ReadLength - 1 - (RepeatLength*RepeatCutoff)"
							Identity = 0
							for RepeatBase1, RepeatBase2, RepeatBase3 in zip(Sequence[i:i+RepeatLength], Sequence[i+RepeatLength:i+RepeatLength*2], Sequence[i+RepeatLength*2:i+RepeatLength*3]):
								if RepeatBase1 == RepeatBase2 == RepeatBase3 and RepeatBase1 != "N":
									Identity += 2
								elif RepeatBase1 == RepeatBase2 and RepeatBase1 != "N":
									Identity += 1
								elif RepeatBase1 == RepeatBase3 and RepeatBase1 != "N":
									Identity += 1
								elif RepeatBase2 == RepeatBase3 and RepeatBase2 != "N":
									Identity += 1
							RepeatSetIdentities.append(Identity)
							i += 1

					else: # for cutoff >= 4, this calculation is universally applicable but extremely slow ... (to-be tested)
						while i < ReadLength - 1 - (RepeatLength*RepeatCutoff): #JHL, 20160303, "299 - (RepeatLength*3)" -> "ReadLength - 1 - (RepeatLength*RepeatCutoff)"
							Identity = 0
							for kk in range(RepeatLength):
								RepeatBase = ['']*RepeatCutoff
								for rr in range(RepeatCutoff):
									RepeatBase[rr] = Sequence[i + RepeatLength*rr + kk] #JHL, 20160303, for RepeatBase_i in zip(Sequence[i+RepeatLength*(i-1):i+RepeatLength*i]..) [i=1,2,3]
								MM = mode(RepeatBase)
								if MM[0][0] != "N":
									Identity += (MM[1][0] - 1)
							RepeatSetIdentities.append(Identity)
							i += 1

						# Alternative Definition of Identity: any common pairs contribute (this is the same with Def 1 with RepeatCutoff = 3, but will be different if > 3)
						#else:
						#	for p in range(RepeatCutoff-1):
						#		for q in range(p+1, RepeatCutoff):
						#			if RepeatBase[p] == RepeatBase[q] and RepeatBase[p] != "N":
						#				Identity += 1
						#	if mode(RepeatBase)[1][0] > 2: #JHL, 20160303, avoid over count
						#		M = mode(RepeatBase)[1][0]
						#			Identity -= (M-1)*(M-2)/2 
						# End of Definition 2
						
						# <=== JHL, 20160303, rewrite the hardcoded 3 repeats into flexible number 

					'''
					#while i < 299 - (RepeatLength*3):
						# original hardcoded implementation ===> 
						for RepeatBase1, RepeatBase2, RepeatBase3 in zip(Sequence[i:i+RepeatLength], Sequence[i+RepeatLength:i+RepeatLength*2], Sequence[i+RepeatLength*2:i+RepeatLength*3]):
							if RepeatBase1 == RepeatBase2 == RepeatBase3 and RepeatBase1 != "N":
								Identity += 2
							elif RepeatBase1 == RepeatBase2 and RepeatBase1 != "N":
								Identity += 1
							elif RepeatBase1 == RepeatBase3 and RepeatBase1 != "N":
								Identity += 1
							elif RepeatBase2 == RepeatBase3 and RepeatBase2 != "N":
								Identity += 1
						# <=== original hardcoded implementation 

						RepeatSetIdentities.append(Identity)
						i += 1
					'''	

					#checkpoint for developer
					#print RepeatSetIdentities
					#sys.exit(1)
					#StartPosition = RepeatSetIdentities.index(max(RepeatSetIdentities))
					#Select the highest identity set of repeats that is at least 85% identity
					#if max(RepeatSetIdentities)/(RepeatLength*2.0) < 0.85:
					if RepeatCutoff > 1 and max(RepeatSetIdentities)/((RepeatLength)*(1.0*(RepeatCutoff-1))) < 0.85: #JHL, 20160303	
						counter_LowIdentity += 1	
					else:
						counter_ConsensusSequences += 1
						StartPosition = RepeatSetIdentities.index(max(RepeatSetIdentities))
####Debug line
#						print StartPosition
#						print max(RepeatSetIdentities)/((Seq_Length-StartPosition-1-RepeatLength)*(1.0*(RepeatCutoff-1)))
		
						#Form consensus sequences and recalculate quality scores
						ConsensusSequence = ""
						ReCalculatedQualityScores = ""

#Section of overhang(generated by trimming) filler: Sam, 20170517

						Loop_end = ReadLength - Seq_Length
						for i in range(1,Loop_end):
							Sequence += "N"
						for i in range(1,Loop_end):
							#QualityScores += "#" 
							QualityScores += "!" #CTH, 20181218, change ! to make easier coding for 3 repeat.


						####Debug line
#						print Sequence
#End of section						
						# JHL, 20160303, rewrite the hardcoded 3 repeats into flexible number ===>
						for kk in range(RepeatLength):
							RepeatBase = ['']*RepeatCutoff
							RepeatQualityScore = ['']*RepeatCutoff 
							for rr in range(RepeatCutoff):
								RepeatBase[rr] = Sequence[StartPosition + RepeatLength*rr + kk] #JHL, 20160303, for RepeatBase_i in zip(Sequence[StartPosition+i*RepeatLength:SP+i+RepeatLength*i]..) [i=1,2,3]
								RepeatQualityScore[rr] = QualityScores[StartPosition + RepeatLength*rr + kk] #JHL, 20160303, ditto
							
							if RepeatCutoff == 1: #JHL, 20160303, cutoff=1, no repeats required
								ConsensusSequence += RepeatBase[0]
								ReCalculatedQualityScores = RepeatQualityScore[0]

							elif RepeatCutoff == 2: #fast but stupid hardcode for cutoff = 2
								if RepeatBase[0] == RepeatBase[1] and RepeatBase[0] != "N":
####Debug line
#									print RepeatBase[0]
									ConsensusSequence += RepeatBase[0]
									ReCalculatedQualityScores += chr(int(round(((ord(RepeatQualityScore[0]) + ord(RepeatQualityScore[1]) - 33*RepeatCutoff)/(1.0*RepeatCutoff)))) + 33)
								else:
									RepeatQualityScores = [ord(x) for x in RepeatQualityScore]
									ConsensusSequence += RepeatBase[RepeatQualityScores.index(max(RepeatQualityScores))]
####Debug line
#									print RepeatBase[RepeatQualityScores.index(max(RepeatQualityScores))]
									print kk, rr
									SortedBasesAndQualityScores = sorted(izip(RepeatBase, RepeatQualityScores), key=lambda x: x[1])
									print SortedBasesAndQualityScores
									RepeatBases, RepeatQualityScores = [[x[i] for x in SortedBasesAndQualityScores] for i in range(2)]
									print RepeatBases, RepeatQualityScores
									if RepeatBases[0] == "N":
										RawProbability1 = 1	#20181218, If base are N, tune RawProbablity to be 1.
									else:
										RawProbability1 = 1-(1.0/RepeatCutoff)*(10**((RepeatQualityScores[0]-33)/-10.0))
####Debug line
#										print RawProbability1
									if RepeatBases[1] == "N":
										RawProbability2 = 1	#20181218, If base are N, tune RawProbablity to be 1.
									else:
										RawProbability2 = 10**((RepeatQualityScores[1]-33)/-10.0)
####Debug line
#										print RawProbability2
									if RawProbability1 == 1 or RawProbability2 == 1:
										RawProbability = 1 
									else:
										RawProbability = RawProbability1*RawProbability2
									ReCalculatedQualityScores += chr(int(round(-10*math.log10(RawProbability)*1.0/RepeatCutoff))+33)	

							elif RepeatCutoff == 3: #fast but stupid hardcode for cutoff = 3
								if RepeatBase[0] == RepeatBase[1] == RepeatBase[2] and RepeatBase[0] != "N": 
									ConsensusSequence += RepeatBase[0]	
									ReCalculatedQualityScores += chr(int(round(((ord(RepeatQualityScore[0]) + ord(RepeatQualityScore[1]) + ord(RepeatQualityScore[2]) - 33*RepeatCutoff)/(1.0*RepeatCutoff)))) + 33)
								elif RepeatBase[0] == RepeatBase[1] and RepeatBase[0] != "N":	
									ConsensusSequence += RepeatBase[0]
									RawProbability = (10**((ord(RepeatQualityScore[0])-33)/-10.0))*(10**((ord(RepeatQualityScore[1])-33)/-10.0))*(1-(1/3.0)*(10**((ord(RepeatQualityScore[2])-33)/-10.0)))
									ReCalculatedQualityScores += chr(int(round(-10*math.log10(RawProbability)/(1.0*RepeatCutoff)))+33)
								elif RepeatBase[0] == RepeatBase[2] and RepeatBase[0] != "N":	
									ConsensusSequence += RepeatBase[0]
									RawProbability = (10**((ord(RepeatQualityScore[0])-33)/-10.0))*(10**((ord(RepeatQualityScore[2])-33)/-10.0))*(1-(1/3.0)*(10**((ord(RepeatQualityScore[1])-33)/-10.0)))
									ReCalculatedQualityScores += chr(int(round(-10*math.log10(RawProbability)/(1.0*RepeatCutoff)))+33)
								elif RepeatBase[1] == RepeatBase[2] and RepeatBase[1] != "N":	
									ConsensusSequence += RepeatBase[1]
									RawProbability = (10**((ord(RepeatQualityScore[1])-33)/-10.0))*(10**((ord(RepeatQualityScore[2])-33)/-10.0))*(1-(1/3.0)*(10**((ord(RepeatQualityScore[0])-33)/-10.0)))
									ReCalculatedQualityScores += chr(int(round(-10*math.log10(RawProbability)/(1.0*RepeatCutoff)))+33)
								else:
									
									RepeatQualityScores = [ord(x) for x in RepeatQualityScore]
									ConsensusSequence += RepeatBase[RepeatQualityScores.index(max(RepeatQualityScores))]
									SortedBasesAndQualityScores = sorted(izip(RepeatBase, RepeatQualityScores), key=lambda x: x[1])
									RepeatBases, RepeatQualityScores = [[x[i] for x in SortedBasesAndQualityScores] for i in range(2)]
									if RepeatBases[0] == "N":
										RawProbability1 = 1
									else:
										RawProbability1 = 1-(1.0/RepeatCutoff)*(10**((RepeatQualityScores[0]-33)/-10.0))
									if RepeatBases[1] == "N":
										RawProbability2 = 1
									else:
										RawProbability2 = 1-(1.0/RepeatCutoff)*(10**((RepeatQualityScores[1]-33)/-10.0))
									RawProbability = RawProbability1 * RawProbability2 * (10**((RepeatQualityScores[2]-33)/-10.0))
									ReCalculatedQualityScores += chr(int(round(-10*math.log10(RawProbability)*1.0/RepeatCutoff))+33)

							else: #for cutoff >= 4, this calculation is universally applicable but a bit slow (not entirely unacceptable though) ...
								M = mode(RepeatBase)
								if M[1][0] > 1 and M[0][0] != "N":
									ConsensusSequence += M[0][0]
									RepeatIndices = [x.start() for x in re.finditer(M[0][0], ''.join(RepeatBase))]
									OtherIndices = [x for x in range(len(RepeatBase)) if x not in RepeatIndices]
									RawProbability = 1
									for e in RepeatIndices:
										RawProbability *= (10**((ord(RepeatQualityScore[e])-33)/-10.0)) 
									for e in OtherIndices:
										RawProbability *= (1-(1.0/RepeatCutoff)*(10**((ord(RepeatQualityScore[e])-33)/-10.0)))
									ReCalculatedQualityScores += chr(int(round(-10*math.log10(RawProbability)*1.0/RepeatCutoff))+33)

								else: #All bases are different or Ns
									RepeatQualityScores = [ord(x) for x in RepeatQualityScore]
									ConsensusSequence += RepeatBase[RepeatQualityScores.index(max(RepeatQualityScores))]
									#Sort lists of Bases and Quality scores based on Quality scores
									SortedBasesAndQualityScores = sorted(izip(RepeatBases, RepeatQualityScores), key=lambda x: x[1])
									RepeatBases, RepeatQualityScores = [[x[i] for x in SortedBasesAndQualityScores] for i in range(2)]
									if RepeatBases[0] == "N":
										RawProbability1 = 1
									else:
										RawProbability1 = 1-(1.0/RepeatCutoff)*(10**((RepeatQualityScores[0]-33)/-10.0))
									if RepeatBases[1] == "N":
										RawProbability2 = 1
									else:
										RawProbability2 = 1-(1.0/RepeatCutoff)*(10**((RepeatQualityScores[1]-33)/-10.0))
									RawProbability = RawProbability1 * RawProbability2 * (10**((RepeatQualityScores[2]-33)/-10.0)) 
									ReCalculatedQualityScores += chr(int(round(-10*math.log10(RawProbability)*1.0/RepeatCutoff))+33)
									
						# <=== JHL, 20160303, rewrite the hardcoded 3 repeats into flexible number
						
						'''
							
						# original hardcoded implementation ===>
						for RepeatBase1, RepeatBase2, RepeatBase3, RepeatQualityScore1, RepeatQualityScore2, RepeatQualityScore3 in zip(Sequence[StartPosition:StartPosition+RepeatLength], Sequence[StartPosition+RepeatLength:StartPosition+RepeatLength*2], Sequence[StartPosition+RepeatLength*2:StartPosition+RepeatLength*3],QualityScores[StartPosition:StartPosition+RepeatLength], QualityScores[StartPosition+RepeatLength:StartPosition+RepeatLength*2], QualityScores[StartPosition+RepeatLength*2:StartPosition+RepeatLength*3]):
							if RepeatBase1 == RepeatBase2 == RepeatBase3 and RepeatBase1 != "N":
								ConsensusSequence += RepeatBase1
								print 'you get into the original code'		#Sam, 20170516: Coding to see if QS calculation enter this loop
								ReCalculatedQualityScores += chr(int(round(((ord(RepeatQualityScore1) + ord(RepeatQualityScore2) + ord(RepeatQualityScore3) - 99)/3.0))) + 33)
							elif RepeatBase1 == RepeatBase2 and RepeatBase1 != "N":
								ConsensusSequence += RepeatBase1
								RawProbability = (10**((ord(RepeatQualityScore1)-33)/-10.0))*(10**((ord(RepeatQualityScore2)-33)/-10.0))*(1-(1/3.0)*(10**((ord(RepeatQualityScore3)-33)/-10.0)))
								ReCalculatedQualityScores += chr(int(round(-10*math.log10(RawProbability)/3.0))+33)
							elif RepeatBase1 == RepeatBase3 and RepeatBase1 != "N":
								ConsensusSequence += RepeatBase1
								RawProbability = (10**((ord(RepeatQualityScore1)-33)/-10.0))*(10**((ord(RepeatQualityScore3)-33)/-10.0))*(1-(1/3.0)*(10**((ord(RepeatQualityScore2)-33)/-10.0)))
								ReCalculatedQualityScores += chr(int(round(-10*math.log10(RawProbability)/3.0))+33)
							elif RepeatBase2 == RepeatBase3 and RepeatBase2 != "N":
								ConsensusSequence += RepeatBase2
								RawProbability = (10**((ord(RepeatQualityScore3)-33)/-10.0))*(10**((ord(RepeatQualityScore2)-33)/-10.0))*(1-(1/3.0)*(10**((ord(RepeatQualityScore1)-33)/-10.0)))
								ReCalculatedQualityScores += chr(int(round(-10*math.log10(RawProbability)/3.0))+33)
							else: #All bases are different or Ns
								RepeatQualityScores = [ord(RepeatQualityScore1), ord(RepeatQualityScore2), ord(RepeatQualityScore3)]
								RepeatBases = [RepeatBase1, RepeatBase2, RepeatBase3]
								ConsensusSequence += RepeatBases[RepeatQualityScores.index(max(RepeatQualityScores))]
								#Sort lists of Bases and Quality scores based on Quality scores
								SortedBasesAndQualityScores = sorted(izip(RepeatBases, RepeatQualityScores), key=lambda x: x[1])
								RepeatBases, RepeatQualityScores = [[x[i] for x in SortedBasesAndQualityScores] for i in range(2)]
								if RepeatBases[0] == "N":
									RawProbability1 = 1
								else:
									RawProbability1	= 1-(1/3.0)*(10**((RepeatQualityScores[0]-33)/-10.0))
								if RepeatBases[1] == "N":
									RawProbability2 = 1
								else:
									RawProbability2	= 1-(1/3.0)*(10**((RepeatQualityScores[1]-33)/-10.0))
								RawProbability = RawProbability1 * RawProbability2 * (10**((RepeatQualityScores[2]-33)/-10.0))
								ReCalculatedQualityScores += chr(int(round(-10*math.log10(RawProbability)/3.0))+33)
						# <=== original hardcoded implementation 
						'''		
						outfile.write(SequenceID)
						outfile.write(ConsensusSequence + "\n")
						outfile.write(EmptyLine)
						outfile.write(ReCalculatedQualityScores + "\n")
	counter_TotalReads -= 1	#20181218, there is one read overcount in the script, this is add to fix it.
							
	return counter_PoorQuality, counter_NoRepeats, counter_AbnormalRepeatLength, counter_LowIdentity, counter_ConsensusSequences, counter_TotalReads, RepeatLengths
